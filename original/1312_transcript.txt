n\nThe comic pokes fun at Haskell, a functional programming language. Functional programming languages are based on the mathematical concept of a function, that is two calls to a function always produce the same results given the same inputs. Side effects of a function call are changes to the program state or observable interactions with the outside world, other than returning a value. As a simple example, if a sum function changes a global variable, or prints the sum before returning it, those are side effects. Functions in most other languages frequently have side effects, typically making them hard to analyze. Functional programming languages seek to avoid side effects when possible. Pure functional programming language like Haskell push this agenda by isolating the inevitable side-effects (input/output at least) through the type system (more specifically in monads for Haskell).\nThe first joke says that Haskell only has no side effects because no one ever uses Haskell programs. Even in a traditional procedural programming language like C, if the program does not run it can\'t have side effects.\nIn Haskell effects are first class values. This means that you can use effects just like any value, assign them to a variable, pass them around, or manipulate them to make new and different effects. Thus, there are technically no side effects, only primary effects.\nThe title text is a joke about Haskell\'s lazy evaluation. The basic concept is that a value is not computed until it is actually used. Thus, it is possible to have a name representing the entire infinite list of Fibonacci numbers. However, until a particular element of the list is accessed, no work is actually done. The joke plays on "called" (referring to calling a function) vs. "called for" (requesting); thus Haskell may have value but no one has either invoked it to get that value or requested such a language. A simpler example may be:\n\nor :: Bool -&gt; Bool -&gt; Bool\nor True _ = True\nor _ b = b\n\nor (2 + 2 == 4) (even (fibonacci 10000))\n\nThe "or" function is defined as a normal function but can conclude instantly without computing the 10000th Fibonacci number (a daunting task) since this second parameter isn\'t necessary&#160;: "true or whatever" is always true.\nIn reality, Haskell is indeed actively used, though it is not one of the most popular languages. It is in particular used by some financial institutions, safety conscious start-ups and websites (there are several active web frameworks in Haskell) like Randall\'s own [1].\n\n