n\nThis comic is a series of programming jokes about a ridiculous new programming language, perhaps inspired by Mathematica and Wolfram Language \xe2\x80\x94 the latter was used by Randall many times before. Maybe it\'s also inspired by Gary Bernhardt\'s CodeMash 2012 lightning talk on JavaScript\'s unpredictable typing. In the talk, the highly technical audience was unable to correctly guess the results of adding various JavaScript types and roared with laughter when they were revealed. The programming language shown in this comic has types even more unpredictable than JavaScript.\nMost regular programming languages distinguish types, e.g. integers, strings, lists\xe2\x80\xa6 all of which have different behaviours. But for instance, the operation "+" is usually conventionally defined over more than one of these types. Applied to two integers, it returns their sum.  Applied to two strings (denoted by being enclosed in quotes) it concatenates them:\n&gt; 2 + 35\n&gt; "123" + "abc""123abc"\nWhile these behaviours are standard, conventional, and intuitive, there is a huge amount of variation among programming languages when you apply an operation like "+" to different types. One logical approach is to always return an error in all cases of type mixing, but it is often practical to allow some case mixing, since it can hugely simplify expressions. Variation and lack of a clearly more intuitive behaviour leads some languages to have weird results when you mix types.\nWeird results abound in the new XKCD programming language:\n\n 2 + "2" uses the + operator on a number and a string. In some programming languages, this might result in the number 4 in math addition, or "22" in string concatenation; however, the new language converts the string to an integer, adds them to produce 4 and converts back to a string. Alternately, it may instead be adding 2 to the ASCII value of the character "2" (50), resulting in the character "4" (52). This is (somewhat) consistent with the behavior for item 4.\n "2" + [] adds a string to an array or list. This first inexplicably converts the string to a number again, and then it literally adds the number to the list by prepending it. And then the result (the entire array) is converted to a string again.\n (2/0) divides 2 by 0 and quite reasonably results in NaN, meaning "Not a Number", though in most languages, as prescribed by the IEEE 754 standard for floating point numbers, dividing a nonzero number by zero would instead return an infinity value.\n (2/0)+2 adds 2 to NaN. 2 Is "added" to the string "NaN" as again, the number is converted to a string for apparently no reason, which produces "NaP". If the language\'s convention is to add to the ASCII value of a character or string, then in this case it added 2 to the character "N" (78), resulting in "P" (80). How the string "NaP" is converted into a bare NaP with undefined meaning is not clear. It is possible the "NaP" means "Not a Positive" as opposed to "Not a Negative".  It could also mean "Not a Prayer", as you\'re taking a "NaN" condition and trying to do more with it.\n ""+"": In many languages, two consecutive double-quote characters denote an empty string, so this expression would concatenate two empty strings, resulting in an empty string.  However,  it appears that this language treats only the outermost quotes of the expression as the string boundary, so all of the characters between them become part of the literal string, producing \'"+"\' (In many programming languages, you can use both " or \' to delimit strings and both behave similar if not identical). Alternately, theses two consecutive double quotes may be treated similar to the way that consecutive single quotes are treated in a SQL string, with the first quote escaping the 2nd. This would result in a string that contains the value "+".\n [1,2,3]+2 seems to test whether it\'s sound to append 2 to the list [1,2,3], and concludes that it doesn\'t fit the pattern, returning the boolean value false. It could conceivably also be the result of an attempt to add 2 to the set [1,2,3], which already contains that element (although {1,2,3} would be a more common notation for sets).\n [1,2,3]+4 returns true for much the same reason.\n 2/(2-(3/2+1/2)) is a floating point joke. Floating point numbers are notoriously imprecise. With precise mathematics, (3/2+1/2) would be exactly 2, hence the entire thing would evaluate to 2/0 or NaN in Randall\'s new language. However, the result of (3/2+1/2) is "just slightly off," which makes the result "just slightly off" of NaN, which would be ridiculous in a real language. The ironic thing is that fractions with 2 in the denominator are not the kind of numbers that typically suffer from floating point impreciseness. Additionally, if there was indeed a rounding error, the actual calculation becomes something like 2/0.000000000000013, which should not return a NaN since it is not division by zero. It is most likely not a coincidence that there are 13 zeros before the "13" at the end of the "decimal".\n RANGE(" ") normally wouldn\'t make any sense. However, the new language appears to interpret it as ASCII, and in the ASCII table, character #32 is space, #33 is !, and #34 is ". So, instead of interpreting " " as a string, it seems to be interpreted as 34, 32, 34 (in ASCII), and then range appears to transform this into 34, 33, 32, 33, 34 (the "ranges" between the numbers), which, interpreted as ASCII, becomes (\'"\',\'!\',\' \',\'!\',\'"\').\n +2 adds 2 to the line number, 10, and returns the result, 12.\n 2+2 would normally be 4. However, the interpreter takes this instruction to mean that the user wishes to increase the actual value of the number 2 (aka the "literal value") by 2 for the remainder of the program, making it 4 and then reports that the work is "Done".  The result can be seen in the subsequent lines where all 2s are replaced by 4s. This could be a reference to languages like Fortran where literals could be assigned new values.\n\n14. RANGE(1,5) would normally return (1,2,3,4,5); however, because the value of 2 has been changed to 4, it returns (1,4,3,4,5). This also affects the line number by changing the "2" in 12 to "4" resulting in the line number 14.\n\n13. FLOOR(10.5) should return 10 (the "floor" of a decimal number is that number rounded down); however, it instead returns ASCII art of the number on a "floor."\n\nThe title text contains three further examples relating to color. color.rgb("blue") returns the hexadecimal code for pure blue (as would be used in HTML, for example), which is how a real programming language might work. The lookup for "yellowish blue" returns "NaN" (Not a Number) again, which makes sense at one level because there is no such color as "yellowish blue" (yellow and blue are opposites on the RGB color triangle, making yellowish-blue an impossible colour, which can only be perceived with great difficulty through contrived figures). However a more typical result would have been a failure indicating that the color database does not include the name, in the same way that a typo such as "bluw" would. (Note that HTML does explicitly attempt to handle all "color names". For the record, "yellowish blue" is a dark blue with an imperceptible amount of red \xe2\x80\x94 #0E00B0.) Similarly sorting the colors would normally produce some defined ordering, such as alphabetical, but in this language it generates the string "rainbow". It seems that Randall\'s new language understands color theory in an unusually deep way.\n\n